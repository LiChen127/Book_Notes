# 第二章 相对单位

## 2.1 相对单位的好处

CSS为网页带来了后期绑定(late binding)的样式: 直到内容和样式都加载完毕，二者才会结合起来

### 2.1.1 像素级完美

在Web环境下，用户可以设置浏览器窗口的大小，而CSS必须适应这种窗口大小。此外，当网页打开后，用户还可以缩放网页，CSS还需要适应新的限制。
也就是说，不能在刚创建网页时就应用样式，而是等到要将网页渲染到屏幕上时，才能去计算样式。这给CSS增加了一个抽象层。我们无法根据理想的条件给元素添加样式，而是要设置无论元素处于任意条件，都能够生效的规则。

### 2.1.2 像素级完美的时代终结了

响应式——在CSS中指的是样式能够根据浏览器窗口的大小有不同的“响应”​。这要求有意地考虑任何尺寸的手机、平板设备，或者桌面屏幕

相对单位就是CSS用来解决这种抽象的一种工具。我们可以基于窗口大小来等比例地缩放字号，而不是固定为14px，或者将网页上的任何元素的大小都相对于基础字号来设置，然后只用改一行代码就能缩放整个网页。

**像素，点，派卡**

CSS支持几种绝对长度单位，最常用，最基础的是像素(px)
不常用的mm, cm, in, pt, pc

像素是一个具有误导性的名称，CSS像素并不严格等于显示器的像素，尤其在高清屏（视网膜屏）下。尽管CSS单位会根据浏览器、操作系统或者硬件适当缩放，在某些设备或者用户的分辨率设置下也会发生变化，但是96px通常等于一个物理英寸的大小。

## 2.2 em和rem

em是最常见的 **相对长度** 单位，它基于当前字体的大小。
```css
body {
  font-size: 16px;
  font-size: 1em;
}
/* 设置内边距的值为1em，浏览器将其乘以字号，最终渲染为16px， 浏览器会根据相对单位的值计算出绝对值，称为计算值 */
```
### 2.2.1 使用em定义字号

谈到font-size属性时，em表现得不太一样。之前提到过，当前元素的字号决定了em。
但是，如果声明font-size: 1.2em，会发生什么呢？一个字号当然不能等于自己的1.2倍。实际上，这个font-size是根据继承的字号来计算的。
```css
body {
  font-size: 16px;
}

h1 {
  font-size: 1.2em; /* 16px * 1.2 = 19.2px */
}
```

#### 1. em同时用于字号和其他属性

现在你已经用em定义了字号（基于继承的字号）​，而且也用em定义了其他属性，比如padding和border-radius（基于当前元素的字号）​。
em的复杂之处在于同时用它指定一个元素的字号和其他属性。这时，浏览器必须先计算字号，然后使用这个计算值去算出其余的属性值。这两类属性可以拥有一样的声明值，但是计算值不一样。

```css
body {
  font-size: 16px;
}

.slogan {
  font-size: 1.2em; /* 16px * 1.2 = 19.2px */
  padding: 1.2em; /* 16px * 1.2 * 1.2 = 23.04px */
}
```

#### 2. 字体缩小的问题

当用em来指定多重嵌套的元素的字号时，就会产生意外的结果。
为了算出每个元素的准确值，就需要知道继承的字号，如果这个值是在父元素上用em定义的，就需要知道父元素的继承值，以此类推，就会沿着DOM树一直往上查找。

<!-- 嵌套列表 -->
```html
<ul class="menu">
  <li>Item 1</li>
  <li>Item 2</li>
  <li>Item 3</li>
</ul>

<style>
  .menu {
    font-size: 1.2em;
  }
</style>
```

### 2.2.2 使用rem定义字号

当浏览器解析HTML文档时，会在内存里将页面的所有元素表示为DOM（文档对象模型）​。
它是一个树结构，其中每个元素都由一个节点表示。\<html>元素是顶级（根）节点。它下面是子节点，\<head>和\<body>。
再下面是逐级嵌套的后代节点。在文档中，根节点是所有其他元素的祖先节点。
根节点有一个伪类选择器（:root）​，可以用来选中它自己。这等价于类型选择器html，但是html的优先级相当于一个类名，而不是一个标签。

**rem**是root em的缩写，rem不是相对于当前元素，而是相对于根元素的单位。

不管在文档的什么位置使用rem,1.2rem都会有相同的计算值：1.2乘以根元素的字号。

```css
:root {
  font-size: 1em;
}

.slogan {
  font-size: 0.8rem; /* 16px */
}
```

## 2.3 停止像素思维

### 2.3.1 设置一个合理的默认字号

```css
:root {
  font-size: 0.875rem;
}
```

### 2.3.2 响应式

```css
:root {
  font-size: 0.75em;
}

@media (min-width: 800px) {
  :root {
    font-size: .875em;
  }
}

@media (min-width: 1200px) {
  :root {
    font-size: 1em;
  }
}
```

如果你足够严格，整个网页的样式都像这样使用相对单位定义，那么网页就会根据视口大小整体缩放。

## 2.4 视口的相对单位

相对于浏览器视口定义长度的视口的相对单位

**视口**: 浏览器窗口里网页可见部分的边框领域。不包括浏览器的地址栏，工具栏，状态栏

- vw: 视口宽度的1/100
- vh: 视口高度的1/100
- vmin: 视口较小尺寸的1/100
- vmax: 视口较大尺寸的1/100

### 2.4.1 使用vw定义字号


如果给一个元素加上font-size: 2vw会发生什么？在一个1200px的桌面显示器上，计算值为24px（1200的2%）​。
在一个768px宽的平板上，计算值约为15px（768的2%）​。这样做的好处在于元素能够在这两种大小之间平滑地过渡，这意味着不会在某个断点突然改变。当视口大小改变时，元素会逐渐过渡。

### 2.4.2 使用calc()定义字号

```css
body {
  font-size: calc(16px + 2vw);
}
```

## 2.5 无单位的数值和行高

有些属性允许无单位的值（即一个不指定单位的数）​。支持这种值的属性包括line-height、z-index、font-weight（700等于bold,400等于normal，等等）​。任何长度单位（如px、em、rem）都可以用无单位的值0，因为这些情况下单位不影响计算值，即0px、0%、0em均相等。

```css
body {
  line-height: 1.5;
}

.slogan {
  font-size: 2em;
}
```

用有单位的值定义行高，会产生意想不到的结果

```css
body {
  line-height: 1.2em;
}

.slogan {
  font-size: 2em; /* 2 * 16px = 32px */
}
```

当一个元素的值定义为长度（px、em、rem，等等）时，子元素会继承它的计算值。当使用em等单位定义行高时，它们的值是计算值，传递到了任何继承子元素上。如果子元素有不同的字号，并且继承了line-height属性，就会造成意想不到的结果，比如文字重叠。

## 2.6 自定义属性(CSS变量)

2015年，层叠变量的自定义属性(Custom Properties for Cascading Variables)被引入CSS。

这个规范给CSS引进了变量的概念，开启了一种全新的基于上下文的动态样式。你可以声明一个变量，为它赋一个值，然后在样式表的其他地方引用这个值。

自定义属性的声明能够层叠和继承：可以在多个选择器中定义相同的变量，这个变量在网页的不同地方有不同的值。
