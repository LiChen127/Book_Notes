# 凤凰架构

## 演进中的架构

### 服务架构演进史

#### 原始分布式时代

在20世纪70年代末期到80年代初，计算机科学刚经历了从以大型机为主向以微型机为主的蜕变，计算机逐渐从一种存在于研究机构、实验室当中的科研设备，转变为存在于商业企业中的生产设备，甚至是面向家庭、个人用户的娱乐设备。此时的微型计算机系统通常具有16位寻址能力、不足5MHz时钟频率的处理器和128KB左右的内存地址空间。譬如著名的英特尔处理器的鼻祖Intel 8086处理器，**就是在1978年研制成功**，流行于80年代中期，甚至一直持续到90年代初期仍在生产销售。

20世纪70年末期到80年代初期，计算机系统开始从单机走向分布式，分布式系统开始出现。

"开放软件基金会"共同制定了"分布式运算环境"(Distributed Computing Environment, DCE)，并推出了开放的分布式操作系统OSF/1。

DCE包含一套相对完整的分布式服务组件规范与参考实现，譬如源自NCA的远程服务调用规范(Remote Procedure Call，RPC)，当时被称为DCE/RPC，它与后来Sun公司向互联网工程任务组(Internet Engineering Task Force，IETF)提交的基于通用TCP/IP协议的远程服务标准ONC RPC被认为是现代RPC的共同鼻祖

**UNIX的分布式设计哲学**
保持接口与实现的简单性，比系统的任何其他属性，包括准确性，一致性和完整性，都来得更加重要。

**原始分布式时代的教训**
某个功能能够进行分布式，并不意味着它就应该进行分布式，强行追求透明的分布式操作，只会自寻苦果

20世纪80年代正是摩尔定律开始稳定发挥作用的黄金时期，微型计算机的性能以每两年增长一倍的惊人速度提升，硬件算力束缚软件规模的链条很快变得松动，信息系统进入以单台或少量几台计算机即可作为服务器来支撑大型信息系统运作的单体时代，且在很长的一段时间内，单体都将是软件架构的绝对主流。

#### 单体架构时代
单体架构”在整个软件架构演进的历史进程里，是出现时间最早、应用范围最广、使用人数最多、统治历史最长的一种架构风格，但“单体”这个名称，却是在微服务开始流行之后才“事后追认”所形成的概念。

- 纵向: 单体架构完全不会展露出丝毫的弱势，反而可能会因更容易开发、部署、测试而获得更好的便捷性
- 横向: 单体架构也支持按照技术、功能、职责等维度，将软件拆分为各种模块，以便重用和管理代码。单体系统并不意味着只能有一个整体的程序封装形式，如果需要，它完全可以由多个JAR、WAR、DLL、Assembly或者其他模块格式来构成。即使是从横向扩展(Scale Horizontally)的角度来衡量，在负载均衡器之后同时部署若干个相同的单体系统副本，以达到分摊流量压力的效果，也是非常常见的需求。
- 拆分: 单体系统的真正缺陷不在如何拆分，而在拆分之后的自治与隔离能力上。由于所有代码都运行在同一个进程内，所有模块、方法的调用都无须考虑网络分区、对象复制这些麻烦的事和性能损失，但在获得进程内调用的简单、高效等好处的同时，也意味着如果任何一部分代码出现缺陷，过度消耗了进程空间内的资源，所造成的影响也是全局性的、难以隔离的。譬如内存泄漏、线程爆炸、阻塞、死循环等问题，都将会影响整个程序，而不仅仅是影响某一个功能、模块本身的正常运作。如果出现问题的是某些更高层次的公共资源，譬如端口号或者数据库连接池泄漏，还将会影响整台机器甚至集群中其他单体副本的正常工作。
- 所有的代码共享一个进程，对于修改时的停机更新，灰度发布，A/B测试更复杂
- 难以实现技术异构
- 很难兼容"Phoenix"的特性,单体架构在规模越来越大的时候，交付会有挑战性

#### SOA时代

##### 烟囱模式(Information Silo Architecture)
使用这种架构的系统也被称为孤岛式信息系统或者烟囱式信息系统。它指的是一种与其他相关信息系统完全没有互操作或者协调工作的设计模式。

##### 微内核架构(Microkernel Architecture)
微内核架构也被称为插件式架构(Plug-in Architecture)。
既然在烟囱式架构中，没有业务往来关系的系统也可能需要共享人员、组织、权限等一些公共的主数据，那不妨就将这些主数据，连同其他可能被各子系统用到的公共服务、数据、资源集中到一块，组成一个被所有业务系统共同依赖的核心（Kernel，也称为Core System）​，
具体的业务系统以插件模块(Plug-in Module)的形式存在，这样也可提供可扩展的、灵活的、天然隔离的功能特性，即微内核架构

##### 事件驱动架构(Event-Driven Architecture)
为了能让子系统互相通信，一种可行的方案是在子系统之间建立一套事件队列管道(Event Queue)，来自系统外部的消息将以事件的形式发送至管道中，各个子系统可以从管道里获取自己感兴趣、能够处理的事件消息，也可以为事件新增或者修改其中的附加信息，甚至可以自己发布一些新的事件到管道队列中去。如此，每一条消息的处理者都是独立的、高度解耦的，但又能与其他处理者（如果存在其他消息处理者的话）通过事件管道进行交互

**SOA**
SOA(Service Oriented Architecture)，即服务驱动架构，是一种面向服务的软件架构风格，它将软件系统分解为多个服务，每个服务都以独立的方式进行部署、扩展和升级，并通过网络进行通信。

#### 微服务时代
“微服务”这个技术名词最早在2005年就已经被提出，由Peter Rodgers博士在2005年的云计算博览会(Web Services Edge 2005)上首次使用，当时的说法是“Micro-Web-Service”​，指的是一种专注于单一职责的、与语言无关的细粒度Web服务(Granular Web Service)。​
“微服务”一词并不是Peter Rodgers凭空创造出来的概念，它最初可以说是SOA发展时催生的产物，就如同EJB推广过程中催生了Spring和Hibernate那样，这一阶段的微服务是作为SOA的一种轻量化的补救方案而被提出的。

**现代微服务的定义**: 微服务是一种通过多个小型服务组合来构建单个应用的架构风格，这些服务围绕业务能力而非特定的技术标准来构建。各个服务可以采用不同的编程语言、不同的数据存储技术，运行在不同的进程之中。服务采取轻量级的通信机制和自动化的部署机制实现通信与运维

- 围绕业务能力构建：微服务是围绕业务能力来构建的，而不是围绕技术能力来构建的。
- 分散管理: 服务对应的开发团队有直接对服务运行质量负责的责任，也有不受外界干预地掌控服务各个方面的权力，譬如选择与其他服务异构的技术来实现自己的服务
- 通过服务来实现独立自治的组件: 之所以强调通过“服务”(Service)而不是“类库”(Library)来构建组件，是因为类库在编译期静态链接到程序中，通过本地调用来提供功能，而服务是进程外组件，通过远程调用来提供功能。前文我们也已经分析过，尽管远程服务有更高昂的调用成本，但这是为组件带来自治与隔离能力的必要代价。
- 产品化思维: 微服务是围绕业务能力来构建的，所以它需要有产品化的思维，才能将业务能力从产品中抽离出来，为产品提供更好的体验。
- 数据去中心化: 微服务明确提倡数据应该按领域分散管理、更新、维护、存储。在单体服务中，一个系统的各个功能模块通常会使用同一个数据库。诚然，中心化的存储天生就更容易避免一致性问题，但是，同一个数据实体在不同服务的视角里，它的抽象形态往往是不同的。
- 强终端弱管道: 微服务提倡使用类似于经典UNIX过滤器那样简单直接的通信方式，所以RESTful风格的通信在微服务中会是更合适的选择。
- 容错性设计: 不再虚幻地追求服务永远稳定，而是接受服务总会出错的现实，要求在微服务的设计中，能够有自动的机制对其依赖的服务进行快速故障检测，在持续出错的时候进行隔离，在服务恢复的时候重新联通。所以“断路器”这类设施，对实际生产环境中的微服务来说并不是可选的外围组件，而是一个必需的支撑点，如果没有容错性设计，系统很容易被一两个服务崩溃所带来的雪崩效应淹没。
- 演进式设计: 容错性设计承认服务会出错，演进式设计则承认服务会被报废淘汰。一个设计良好的服务，应该是能够报废的，而不是期望得到长存永生。假如系统中出现不可更改、无可替代的服务，这并不能说明这个服务多么优秀、多么重要，反而是一种系统设计上脆弱的表现，微服务所追求的自治、隔离，也是反对这种脆弱性的表现。
- 基础设施自动化:基础设施自动化，如CI/CD的长足发展，显著减少了构建、发布、运维工作的复杂性。由于微服务架构下运维对象数量是单体架构运维对象数量的数量级倍，使用微服务的团队更加依赖于基础设施的自动化，人工是很难支撑成百上千乃至上万级别的服务的

#### 后微服务时代
在微服务时代，人们之所以选择在软件的代码层面而不是硬件的基础设施层面去解决这些分布式问题，很大程度上是因为由硬件构成的基础设施跟不上由软件构成的应用服务的灵活性的无奈之举。软件可以只使用键盘命令就拆分出不同的服务，只通过拷贝、启动就能够实现伸缩扩容服务，硬件难道就不可以通过键盘命令变出相应的应用服务器、负载均衡器、DNS服务器、网络链路这些设施吗？

微服务时代所取得的成就，本身就离不开以Docker为代表的早期容器化技术的巨大贡献。
早期的容器只被简单地视为一种可快速启动的服务运行环境，目的是方便程序的分发部署，在这个阶段，针对单个应用进行封装的容器并未真正解决分布式架构问题。尽管2014年微服务开始崛起的时候，Docker Swarm（2013年）和Apache Mesos（2012年）就已经存在，更早之前也出现了软件定义网络(Software-Defined Networking，SDN)、软件定义存储(Software-Defined Storage，SDS)等技术，但是，被业界广泛认可、普遍采用的通过虚拟化基础设施去解决分布式架构问题的开端，应该要从2017年Kubernetes取得容器战争的胜利开始算起。

#### 无服务时代
无服务也是以“简单”为主要卖点的，它只涉及两块内容：后端设施(Backend)和函数(Function)

·后端设施是指数据库、消息队列、日志、存储等这类用于支撑业务逻辑运行，但本身无业务含义的技术组件，这些后端设施都运行在云中，在无服务中将它们称为“后端即服务”(Backend as a Service，BaaS)。
·函数是指业务逻辑代码，这里函数的概念与粒度都已经很接近于程序编码角度的函数了，其区别是无服务中的函数运行在云端，不必考虑算力问题，也不必考虑容量规划（从技术角度可以不考虑，从计费的角度还是要掂量一下的）​，在无服务中将其称为“函数即服务”(Function as a Service，FaaS)。

