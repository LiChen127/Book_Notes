# 模块演绎与require.js

## 模块化的需求推演

### 1. script 标签

在ES Module模块化标准出现以前，JavaScript本身并没有提供任何模块化规范，当我们需要在项目中添加多个依赖时，往往是通过大量的由上到下并列排布的<script>标签来实现的，很容易在旧代码中看到类似下面这样的代码片段：

```html
<script src="a.js"></script>
<script src="b.js"></script>
<script src="c.js"></script>
```

十年前非常流行的jQuery和Bootstrap都拥有极好的插件生态，许多现成的第三方库都可以直接拿来使用，开发者普遍使用上面的方式来引用多个脚本文件。即使是在现代开发中，许多非专业的前端开发者也仍然非常喜欢使用这种方式来引入外部文件，因为这样即使不学习前端构建工具和各种脚手架工具，也很快就可以让自己编写的脚本在浏览器中运行，而且效果还不错。随着项目中的代码日渐增多，这种原始的依赖管理方案的弊端就会逐渐显现出来。如果\<script>标签上没有设置任何延迟执行的属性（defer或async属性）​，那么\<script>标签的执行就会阻塞文档对象模型（Document Object Model，即DOM对象）的解析，加载的脚本文件越多，页面完成初始化的时间就会越长，所以我们经常会看到\<script>标签被放在\<body>标签之后，这可让网站首屏的内容信息先完成解析渲染，再为页面增加交互，因为交互和逻辑能力的增加对用户而言在视觉上几乎是无感知的。

尽管多个\<script>标签看似将不同的代码块隔离到了不同的文件中，但这层代码就像窗户纸一样一捅就破，每一个由\<script>标签引入的脚本文件实际上都是直接暴露在同一个全局作用域之下的，这就意味着如果参与合作的开发者在自己的脚本代码中使用了其他某个文件使用过的标识符，那么只有最后一个被引入的脚本中的定义会生效，而先引入的脚本中的定义全都会被覆盖掉，由此引发的混乱可想而知。

### 2. 代码隔离

为了满足代码隔离的基本要求,业内出现了以立即执行函数(Immediately Invoked Function Expression, 简称IIFE)的第一代模块化解决方案.

```js
;(function (window, undefined) {
  // 模块代码
})(window);
```

在ES6标准之前，JavaScript只能使用函数来划分作用域，也就是说JavaScript需要借助函数来解决多人协作时的代码隔离问题。

#### 1. 开头的分号

在代码段的开头添加分号，是早期的代码合并工具引发的。浏览器在加载网站资源时，同一个域名下的并发连接数是有上限的（一般为6个）​，例如，你的网站引用了7个外部资源，那么前6个资源会先行下载，等到其中一个完成下载后，第7个文件才会开始下载。为了提升加载性能，早期的合并工具会将多个脚本文件合并压缩并生成一个文件，但此时定义当前模块的function语句就会与前一个模块结尾的语句连在一起被解析，这就会引发错误。合并后的脚本文件往往都是经过变量替换的，开发者也很难在生成的文件中手动解决这些错误。而在自执行函数的开头添加一个分号，就能有效避免这种问题。

#### 2. 立即执行函数

上述代码的主体是一段立即执行函数，也就是我们常说的IIFE，小括号将function(){}定义语句括起来，这个括号的作用是将函数定义变成一个表达式（当然这并不是唯一的方法）​，紧接其后的括号里的是函数调用语句，这个匿名函数会在定义后直接运行。这样，函数体中使用的标识符就都只在当前函数作用域有效了，立即执行函数就是通过这种方式来达到代码隔离效果的。

#### 3. 函数的形参和实参

#### 4. undefined

我们知道“undefined”在JavaScript语言中是一个关键字，不仅如此，它还是全局对象的一个属性，它的值被定义为“undefined”​。在低版本的浏览器中，它是可以被赋值修改的，一旦有人恶意修改了“undefined”这个属性的值，那么你写在代码里的所有针对“undefined”的判断逻辑就会混乱。由于立即执行函数中的最后一个形参没有对应于任何值，因此其会被自动赋值为真正的“undefined”​，以避免上述风险。另一方面，​“undefined”作为形参时，一些代码压缩工具也会对其进行有效的压缩和变量替换，从而减小文件体积，所以在第三方工具库的脚本文件中，我们经常会看到这种书写风格。在JavaScript中可以使用“void 0”来得到真实的“undefined”​。

#### 5. 与外部作用域的通信

如果我们将所有的模块代码都编写在自执行函数中，那么函数执行结束后，这些模块代码就会被销毁，其中的某些执行结果或定义的方法又该如何传达给外界呢？

常见的方法有两种:

- 函数实参为对象类型时,函数体内只保留对原对象的引用, 对实参执行的所有操作都会影响到原对象. 我们挂载的目标对象实际上是外层 "window" 对象的引用
- 形式上贴近模块化,我们可以把自执行函数内部定义的方法通过 "return" 语句返回,然后将其赋值给另一个遍历,这样函数内部的值或方法就可以传递到函数外部了.
  - 需要注意的是，在IIFE函数体中书写的对于global变量的赋值并不会影响外部的全局对象，它只会让global这个本地变量指向堆内存中的另一个地址，只有当你对global变量的某个属性进行赋值操作时，相应的值才会出现在全局对象上

### 3. 依赖管理

当完整的代码被划分为模块以后，我们又需要对模块的加载顺序和相互之间的依赖关系进行管理。这件事情乍看起来似乎并没有那么重要，在项目依赖较少时，我们可以通过手动排序来避免冲突，随后每一次增加外部依赖，几乎都是按次序继续写在已有的\<script>标签之下，那么为什么要对依赖关系图进行解析管理呢？

1. 尽管HTML标准为\<script>标签提供了defer和async属性，但它们只能控制脚本文件的加载时机，并不能控制脚本文件的执行时机.不同的浏览器实现层面都会有所不同,所以,基于\<script>标签的依赖管理方案在实际项目中是很难保证依赖的执行顺序的.
2. 异步加载会导致依赖关系难以保障.

## 前端规范大杂烩

简单讨论几种常见的JavaScript模块化方案

**概述**: 初级开发者在理解非标准的前端模块化时之所以会感到非常吃力，并不是因为模块化规范本身有多复杂，所谓规范不过是一种约定，对如何定义模块、如何加载模块和如何管理模块的一种约定，即使你的开发经验还不足以理解规范中的每一条要求，仅仅遵从规范要求的格式来编写代码也并不难做到，况且模块化规范中定义的API非常少

主流的模块化管理方案

```js
// AMD
require(['axios'], function (axios) {
  console.log(axios);
});

// CMD
define(function (require) {
  const axios = require('axios');
  console.log(axios);
});

// CommonJS
const axios = require('axios');

// ES6
import axios from 'axios';
```

我们在谈及AMD、CMD和UMD这几种模块定义规范时，事实上都只是在描述工程实践层面的约定，浏览器并没有对它们进行原生支持，也就是说，当你把一个AMD模块或CMD模块直接引入浏览器环境时，浏览器就会报错（UMD模块因为可以兼容无模块化的工程，所以不会报错）​，因此你需要事先引入一个实现了某种模块化规范的库（AMD标准使用Require.js，CMD标准使用Sea.js）​，之后所引入的模块才能够被识别，相当于在运行时预制了模块化管理的代码，它并不受运行环境原生支持。这里有必要提一下UMD模块化规范，它并不是一种具体的规范，而是一种代码模式，遵循UMD规范的模块在加载时，会根据适用的API来推断当前工程所遵循的模块化规范，并以恰当的方式把封装在模块中的内容提供给引用者。

提起CommonJS规范（它是一个模块化规范，并不是外部类库）​，就不得不提起大名鼎鼎的Node.js，它是一个JavaScript语言的服务端运行环境，Node.js对CommonJS模块化规范提供了原生支持，这就意味着使用JavaScript进行服务端开发时，不需要借助任何外部类库，就可以实现模块化管理。遗憾的是，要想让浏览器识别CommonJS模块，通常还需要依赖于构建工具注入的模块加载器代码来实现。

随着ES6标准的出现，JavaScript终于有了自己的模块化规范——ES Module规范，这就意味着将来无论是在浏览器端还是在服务端进行开发，都可以遵从同样的模块化规范，然而这仅仅是一件看起来很美好的事情。随着前端自动化工具的日渐成熟，​“构建”逐渐成为前端开发工作流中的标配，我们可以在源代码中编写符合ES Module规范的模块管理语法，或者是一些还未被正式发布的规范（例如懒加载语法的规范）​，甚至是自创的语句（例如TypeScript中独有的“import...require”模块引用语句）​，新的语法通常会更精简，然后通过各种构建工具编译来得到符合生产环境需求或是能够兼容指定浏览器版本的软件包。自动化工具带来的便利是可想而知的，随着浏览器支持度的升级，只需要在构建工具中调整一些参数，就可以直接从源代码中编译出符合新需求的生产环境代码，而不必担心由此引发的重构负担，等到ES Module的运行时方案稳定后，很容易实现技术方案的迁移。

### 几个重要的差异

#### AMD规范和CMD规范

AMD规范和CMD规范都是浏览器端的模块化规范，它们都使用define()函数来定义模块，使用require()函数来加载模块。

AMD规范推崇模块依赖前置,也就是定义模块时，需要在依赖列表中列举出该模块依赖的其他外部模块。当模块被加载时，加载器会先确保所依赖的模块已被下载和执行，然后在执行当前模块时将这些解析后的模块注入进来（表现上就是当前模块执行时可以通过形参来访问注入的模块）​。

CMD规范推崇在代码中就近编写依赖,通过参数注入的方式为开发者提供了一个加载方法require,开发者可以用它来引用其他模块，所实现的效果就是，被依赖的模块只有在被需要时才会去解析和执行。这里需要注意的是，无论是在何时执行所依赖模块的代码，依赖的模块文件都需要提前下载到本地，不同的只是执行的时机，这种差异在大多数运行场景中带来的差别几乎微乎其微，因为模块解析的耗时其实非常少。

对比各种开发语言的包管理规范，显然开发者更容易接受AMD规范所提倡的前置依赖声明方式。另一方面，规范是比较抽象和严谨的，但代码实现上却可以相对灵活

#### 懒执行与懒加载

当代码中需要引用一个体积较大的外部依赖时，无论是采用AMD规范还是CMD规范的方式来书写，对应模块的下载都是提前进行的，区别只是解析这个模块的时机，CMD的机制通常称为“懒执行”​，但由于模块解析相较于网络请求而言耗时非常短，因此这样的设计并没有表现出显著的差异。在另一种场景中，我们更希望代码首次加载时能够先忽略某个体积较大的库，等用户真正进入某个页面时再下载这个依赖文件，也就是开发者常说的“懒加载”技术，有时也称为“分包加载”​。​“分包加载”是一种宏观的异步行为，它不像AMD或CMD规范中要求的那样需要提前下载依赖，然后按需解析，而是当代码执行到需要外部依赖的时候才会下载该依赖文件，这种处理方式在组件化开发的性能优化中很常见，因为它可以有效减小首屏依赖代码的体积。

#### CommonJS和ESModule

CommonJS规范是Node.js原生支持的模块化管理方案，这个规范并不是JavaScript官方提出的标准，所以浏览器并没有对它提供支持，在JavaScript语言有了自己的模块系统标准后，Node.js势必会跟进并实现这个标准。在CommonJS规范下，既支持具名模块导出，也支持默认模块导出

```js
// 具名模块导出
module.exports = {
  name: 'John',
  age: 30,
};

// 默认模块导出
exports.default = {
  name: 'John',
  age: 30,
};
```
但开发者不能同时使用这两种导出方式，因为exports和module.exports会指向内存中的同一个地址，且最终导出的模块会以module.exports为准

CommonJS中加载模块使用的是require()关键字,它是同步执行的,且只能全量加载模块的导出.

尽管开发者可以像下面这样用类似于ES Module中引用具名模块的语法来编写代码，但实际上它只是将require引用语句和解构赋值语句联合在一起简写罢了，b模块中导出的其他未被使用的模块实际上也会被解析和加载。

ESModue

```js
// import { name, age } from './b.js';
// 具名导入
export { a };

// 默认模块导出
export default {
  name: 'John',
  age: 30,
};

// 引用具名模块
import { a } from './b.js';

// 引用默认模块
import a from './b.js';
```
默认模块的具体名称由引用者自己提供。这样的语法看起来与CommonJS类似，但其运作机制却存在着非常大的差异

**比较这两种模块化的运作机制**

CommonJS

```js
// b.js
module.exports = {};
console.log('in b module');

// a.js
console.log('before require');
const { A } = require('./b.js');
console.log(A);
console.log('after require');

/**
 * 执行结果
 * before require
 * in b module
 * undefined
 * after require
 */
```

ESModule

```js
// b.js
export const A = 'A';
console.log('in b module');

// a.js
console.log('before import');
import { A } from './b.js';
console.log(A);
console.log('after import');

/**
 * 执行结果
 * before import
 * in b module
 * undefined
 * after import
 */
```

CommonJS中的require函数是同步执行的，它将根据Node.js原生提供的寻址策略来寻找模块的定义文件，找到后就会立即执行，require函数可以在代码中的任何地方调用，引用到某个模块时才会去执行相关的代码，这就意味着想要知道一个模块对外到底会导出哪些内容，需要等到运行时才行。而在ES Module规范中，import和export语句只能在顶层作用域中使用，加载器并不会直接运行脚本，它会先对代码进行静态类型检查，构建出完整的“依赖图谱”​，获取并解析这些模块，然后才会从“依赖图”的末端开始执行模块代码，具名模块和默认模块互不干扰.

S Module规范[插图]规定了将文件转换为模块记录（Parse）​、进行实例化（Instantiate）​，以及对模块进行求值（evaluate）的过程，但它并没有规定在此之前应该如何获取模块定义文件。其对于文件的获取方式依赖于加载器的实现，在浏览器环境中它是依赖于HTML标准[插图]的，而浏览器则需要按照ES Module规范中要求的ParseModule、Module.Instantiate和Module.Evaluate方法来实现加载逻辑，以便控制JavaScript引擎加载模块的过程。为了避免对主线程造成阻塞，加载器会先完成模块的远程下载和ParseModule部分，以便构建出模块的依赖关系图谱，等到所有的依赖模块都下载至本地并完成Parse环节后，再执行后续的步骤。

## 模块化规范的兼容与工具演进

我们看到的“兼容”实际上是构建工具通过工程化的手段回避了模块化规范兼容性的问题。

除了IE浏览器之外，主流的浏览器大都实现了基于ES Module的模块系统，Node.js也兼容了CommonJS和ES Module规范（从Node.js v13开始，package.json中声明了“type”:“module”的包都会采用ES Module标准进行解析）​，那么在浏览器环境中加载依赖还存在哪些问题呢？

Node.js中引用第三方依赖时并不需要写相对路径，只需要指定依赖名即可，Node.js模块系统中对路径的处理有一套自己的方案，例如自动拼接node_modules中第三方依赖的完整路径，自动解析package.json中入口字段的声明，自动在末尾补全index文件名或文件扩展名等，而浏览器环境中并没有提供类似的解析策略，要想在浏览器环境中使用ES Module规范来加载CommonJS模块，比较容易想到的处理办法是将第三方依赖转换为ES Module模块，并将模块的引用地址全部替换为独立的线上地址（而不是与开发者编写的代码打包在一起）​，这样浏览器就可以直接加载这些模块了，但这种简单的方式会引发新的问题——“请求爆炸”​。例如最常用的Antd组件库，里面使用的第三方依赖有上千个，如果去掉打包环节直接从浏览器加载这些依赖，那么加载过程就变成了网络请求，仅一个Antd组件库就需要发送近2000个网络请求，这种方案对于首屏渲染的影响是非常大的。

从数量上来看，针对第三方依赖进行打包还是很有必要的。在webpack原本的设计理念中，每次启动本地开发服务器时，都会重新做一次打包，随着项目体量的增大，此操作会变得越来越耗时。但在开发过程中，第三方依赖的代码基本上是维持不变的，只需要预处理一次即可。基于这样的现状，第三方依赖和源代码其实可以拆分为两个维度的概念，也就是将几乎不变的代码和开发者编写的应用层源码拆分开，开发工具不再将其打包在一起，而是为第三方依赖单独构建一个依赖包，以达到一次处理到处使用的目的。随着开发者对技术方案的不断探索，以Snowpack和Vite为代表的下一代WebApp开发工具也随之而生。

以Vite为例，其核心原理就是在启动本地开发服务器之前，先使用开发工具遍历源码目录，将每个文件中的代码转换为AST（抽象语法树）​，然后解析获取其中所有的Import-Declaration类型的节点（即引用声明节点）​，获得所有需要用到的第三方依赖的路径后，将解析出的第三方依赖路径作为多个入口传入传统的构建工具（例如在webpack中通过将entry属性配置为对象来实现多文件入口）​，从而获得一个虚拟的node_modules目录，出现在entry配置对象中的依赖项会继续作为目标文件存在，其他的公共依赖部分则会被打包成一个大的依赖项。接下来工具会跳过对源码的处理，直接启动本地服务器，新的构建工具使用的index.html模板会直接使用ES Module规范的语法来加载源代码的入口文件