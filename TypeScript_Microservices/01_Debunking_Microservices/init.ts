/**
 * 解密微服务
 */

// 微服务开发背后的核心思想是
/**
 * 如果将应用程序分解为更小的独立单元，每个组都很好地执行其功能，那么构建和维护应用程序就变得简单了。然后整个应用程序就变成了独立单元的总和
 */

// 微服务是一个建立自主的、自我维持的、松散耦合的业务能力的现代风格，这些业务能力可以总结为一个完整的系统。

// 原理

/**
 * 1.无单片模块: 微服务与业务单元变更相关联，因此必须松散耦合。微型服务应该能够不依赖于其他业务部门，持续地满足不断变化的业务需求。对于其他服务来说，只是消费的问题，消费方式不应该改变。实现可以在后台进行更改
 * 2.微服务应该留在Node之内，而不是与通信信道融合。通信信道应该是哑的，只在所决定的通信协议里面进行通信。HTTP不错
 * 3.权力下放自治: 在使用微服务时，经常会出现故障变更。一个应急计划，最终阻止故障传播到整个系统。此外，每个微服务可能有其自己的数据存储需求。权力下放恰恰满足了这种需求。
 * 4.服务合同和无维护状态:
 * - 服务契约提供有关如何使用服务以及需要传递给该服务的所有参数的信息
 * - 无维护状态是指服务应该是无状态的，这意味着服务不应该维护任何状态信息。这样，服务可以在任何时间点被替换，而不会影响整个系统
 * 5.微服务轻量级: 有助于在任何托管环境中轻松地复制设置。容器比虚拟机更加受青睐。
 * 6.多语言支持: 微服务应该支持多种语言，以便开发人员可以使用他们最喜欢的语言来开发微服务
 */

// 好处

/**
 * 1. 弹性: 微服务可以独立部署，因此可以独立扩展和缩放。
 * 2. 服务的优雅退化: 如果一个服务失败，整个系统不会失败。只有一个服务会失败。
 * 3. 允许异构和DevOps: 微服务可以以各种方式运行，包括云、容器、虚拟机等。
 * 4. 事件驱动的体系结构: 一个精心设计的微服务将支持异步事件驱动的体系结构。事件驱动的架构很有帮助，因为可以追踪任何事件-每个操作都是任何事件的结果，我们可以利用任何事件来调试问题。微服务是按照发布者-订阅者模式设计的，这意味着添加任何其他只订阅该事件的服务将只是一个任务。
 */

// 复杂性

/**
 * 1.组织与容器
 * 2.平台
 * 3.测试
 * 4.服务发现
 */

// 考虑因素

/**
 * 1.服务退化: 微服务架构允许您隔离失败，从而使您能够隔离失败并获得优雅的降级，因为失败包含在服务的边界内，而不是级联
 * 2.适当的改革: 分布式系统中，服务是相互依赖的。因此，当你引入一个新的变化时，应该给予最大程度的考虑，就像引入了任何副作用或不必要的影响一样，那么它的影响应该是最小的。应提供各种变革管理战略和自动推出选项。此外，在代码管理中应该有适当的治理。开发工作应通过TDD或BDD进行，如果已达到商定的百分比，则应在此基础上推出。
 * 3.健康检查，负载均衡和高效网关路由: 根据业务需求，微服务实例可以启动、重新启动、在某些故障时停止、在内存不足时运行和自动缩放，这可能会使其暂时或永久不可用。因此，架构和框架应该相应地进行设计。例如，单线程的Node.js服务器在发生故障时会立即停止运行，但使用优雅的工具（如 PM2 ）会让它们永远运行。应引入一个网关，作为微服务消费者的唯一联系点。网关可以是一个负载平衡器，应该跳过不健康的微服务实例。负载平衡器应该能够收集健康信息指标并相应路由流量，它应该聪明地分析任何特定微服务的流量，如果需要，它应该触发自动缩放。
 * 4.自固化: 自固化设计可以帮助系统从灾难中恢复。微服务的实现应该能够自动恢复丢失的服务和功能。当服务失败时，Docker等工具会重新启动服务。网飞提供了广泛的工具，作为一个编排层，以实现自我修复。尤里卡服务注册表和Hyst trix断路器是常用的。断路器使您的服务呼叫更具弹性。它们跟踪每个微服务端点的状态。每当遇到超时时，Hystrix就会中断连接，触发修复微服务的需要，然后恢复到某种故障安全策略。Kubernates是另一个选择。如果一个Pod或Pod内的任何容器崩溃，Kubernates将启动系统并保持副本集的完整性。
 * 5.用于故障转移的缓存: 微服务架构应该具有缓存，以减少对数据库的访问。缓存应该具有适当的过期时间，以保持其有效性。
 * 6.自愈能力: 微服务架构应该具有重试逻辑，直到条件具备为止，因为我们可以预期服务会恢复，或者负载平衡器会将服务请求重定向到另一个健康实例。
 */

// 微服务的十二要素应用

/**
 * 1.CodeBase: 每个微服务维护单一代码库
 * 2.Dependency: 明确声明依赖关系
 * 3.Config: 所有的配置都应该根据服务器环境进行外部化。配置和代码要分开
 * 4.Backing Services: 所有服务都作为微服务公开，使用Docker组合，独立于Application
 * 5.Build, Release, Run: 严格分离构建和运行
 * 6.Process: 设计的微服务将是无状态的，不会共享任何东西，因此支持零容错和易于扩展。卷将用于持久化数据，从而避免数据丢失。
 * 7.Port Binding: 微服务应该是自主的和自包含的。微服务应该嵌入服务监听器作为服务本身的一部分。例如，在使用HTTP模块的Node.js应用程序中，服务网络公开处理所有进程端口的服务。
 * 8.Concurrency: 微服务应该是可扩展的，因此应该支持并发。Node.js是一个单线程的应用程序，但是可以使用多个进程来处理并发请求。
 * 9.Disposability: 微服务应该是可处置的，因此应该能够快速启动和停止。Docker容器是一个很好的选择，因为它们可以快速启动和停止。
 * 10.Dev/Prod parity: 开发环境和生产环境应该是相同的。Docker容器是一个很好的选择，因为它们可以在任何环境中运行。
 * 11.Logs: 微服务应该生成日志，以便可以跟踪问题。日志应该是结构化的，以便可以轻松地搜索和过滤。
 * 12.Admin Processes: 微服务应该提供一种机制，以方便管理。例如，使用Docker Compose，您可以轻松地启动和停止微服务。
 */

// 微服务设计

/**
 * 微服务通信
 *
 * 1. 远程过程调用(RPI Remote Procedure Invocation):简而言之，远程过程调用是一种协议，任何人都可以使用它来访问远程网络中任何其他提供者的服务，而不需要了解网络的详细信息。客户端使用请求和响应协议对服务进行请求，是大数据搜索系统中最可行的REST解决方案之一。它具有序列化时间的主要优点之一。
 * RPI使用二进制而不是文本，以保持有效载荷非常紧凑和高效。这些请求通过单个TCP连接进行复用，这可以允许多个并发消息在飞行中，而不必牺牲网络消耗量。
 * 2. 消息传递与消息总线(Messaging and message bus)
 * 当服务必须处理来自不同客户端接口的请求时，使用这种通信模式。服务需要相互协作来处理一些特定的操作，为此它们需要使用进程间通信协议。异步消息传递和消息总线就是其中之一。微服务通过通过各种消息传递通道交换消息来相互通信。
 * 3. 原始文件
 * 协议缓冲区或原始数据包是谷歌创建的一种二进制格式。
 * 谷歌将protobuf定义为一种语言和平台中立的广泛的方式序列化结构化数据，可以作为通信协议之一。
 * Protobuf还定义了一组定义消息结构的语言规则。一些演示有效地表明，protobuf比JSON快六倍。
 * 它非常容易实现，它涉及三个主要阶段，即创建消息描述符、消息实现以及解析和序列化。
 * 4. 服务发现
 * 任何客户端接口或任何微服务发现任何服务实例的网络位置的方法。基于微服务的现代应用程序在虚拟化或容器化环境中运行，在这些环境中，事情会动态变化，包括服务实例的数量及其位置。此外，服务实例集会根据自动缩放、升级等动态变化。我们需要一个完善的服务发现机制。前面讨论的是广泛使用的模式。
 * 5. 服务-服务通信服务注册表
 * 不同的微服务和不同的客户端接口需要知道服务实例的位置，以便发送请求。通常，虚拟机或容器具有不同的或动态的IP地址，例如，EC2组在应用自动伸缩时，它会根据负载自动调整实例的数量。可以使用各种选项在任何位置维护注册表，例如客户端或服务器端注册。客户端或微服务查看注册表以查找用于通信的其他微服务。
 * 6. 服务器端发现
 * 对任何服务提出的所有请求都通过路由器或负载平衡器路由，这些负载平衡器的运行位置为客户端接口所知。
 * 然后路由器查询维护的注册表，并根据查询响应转发请求。AWS弹性负载平衡器是一个典型的示例，它能够处理负载平衡、处理内部或外部流量并充当服务注册表。
 * EC2 实例通过公开API调用或自动缩放方式注册到ELB。其他选项包括NGINX和NGINX Plus。有一些可用的领事模板最终从领事服务注册表生成nginx.conf文件，并可以根据需要配置代理。
 * 7. 客户方发现
 * 在这种发现模式下，客户端负责处理可用微服务的网络位置，并对它们之间的传入请求进行负载均衡。客户端需要查询服务注册表（在客户端维护的可用服务的数据库）​。然后客户端根据算法选择服务实例，然后提出请求。
 * 8. 自登记
 * 在使用此模式时，任何微服务实例都负责从维护的服务注册表中注册和注销自己。为了维持健康检查，服务实例发送心跳请求以防止其注册表过期。
 * 9. 数据管理
 * 微服务设计方面的另一个重要问题是微服务应用程序中的数据库架构。我们将看到各种选项，例如是否维护私有数据存储、管理事务以及使查询数据存储在分布式系统中变得容易
 * 在分布式微服务架构中，不同的服务有不同的存储需求和使用。
 * 在维护关系和进行复杂查询时，关系数据库是一个完美的选择。
 * 当存在非结构化复杂数据时，NoSQL数据库（如MongoDB）是最佳选择。
 * 有些可能需要图形数据，因此使用 Neo4j 或GraphQL。解决方案是将每个微服务数据私有化为该服务，并仅通过API对其进行访问。每个微服务维护其数据存储，并且是该服务实现的私有部分，因此其他服务无法直接访问。
 */

// 微服务设计的问题

// 外部化配置

/**
 * 应用程序通常使用一个或多个基础结构第三方服务，如服务注册表、消息代理、服务器、云部署平台等。
 * 任何服务都必须能够在多个环境中运行，而无需进行任何修改。它应该有能力接收外部配置。
 * 这个模式更多的是一种指导原则，它建议我们外部化所有配置，包括数据库信息、环境信息、网络位置等等，以创建一个启动服务，读取这些信息并相应地准备应用程序。有多种选择可供选择。
 * Node.js提供了环境变量的设置；如果您使用Docker，那么它有docker-compose.yml文件。
 */

// 可观测性

/**
 * 重新审视应用程序所需的十二个因素，我们发现任何应用程序都需要一些集中的特性，即使它是分布式的。
 * 这些集中功能有助于我们在出现问题时进行适当的监控和调试。让我们看看一些需要注意的常见可观察性参数。
 */

// 日志聚合

/**
 * 每个服务实例将以标准化格式生成有关其正在执行的操作的信息，该格式包含不同级别的日志，如错误、警告、信息、调试、跟踪、致命等。
 * 解决方案是使用一个集中的日志记录服务，该服务从每个服务实例收集日志，并将其存储在某个公共位置，用户可以在那里搜索和分析日志。
 * 这使我们能够为某些类型的日志配置警报。此外，集中式服务还有助于进行审计日志记录、异常跟踪和API度量。
 * 可用和广泛使用的框架是Elastic Stack（Elasticsearch、Logstash、Kibana）​、AWS CloudTrail和AWS CloudWatch。
 */

// 分布式跟踪

/**
 * 了解行为和应用，以便在需要时排除故障。这种模式更像是一种设计准则，它规定维护一个唯一的外部请求ID，该ID由一个微服务维护。
 * 此外部请求ID需要传递给处理该请求的所有服务以及所有日志消息中。另一条准则是包括微服务执行操作时所执行的请求和操作的开始时间和结束时间。
 */

// 微服务设计模式

/**
 * 异步消息传递微服务设计模式
 * 
 * 分布式系统中需要考虑的最重要的事情之一就是状态。尽管REST API功能强大，但它有一个非常原始的缺陷，即同步性，因此会造成阻塞。
 * 该模式旨在实现非阻塞状态和异步性，以可靠地在整个应用程序中保持相同的状态，避免数据损坏，并允许在整个应用中更快地改变速度
 * 
 * 由于是异步通信，客户端或呼叫者假设消息不会立即被接收，然后执行并附加一个回调到服务。
 * 回调用于在收到响应时执行下一步操作。
 * 最好使用轻量级消息代理（不要与SOA中使用的编程器混淆）​。
 * 消息代理是愚蠢的，也就是说，他们对应用程序的状态一无所知。
 * 它们与处理事件的服务进行通信，但它们从不处理事件。一些广泛采用的示例包括 RabbitMQ、Azure总线等。Instagram的Feed由这个简单的 RabbitMQ提供支持。
 * 根据项目的复杂程度，您可以引入单个接收器或多个接收器。虽然单个接收器是好的，但很快它就会成为唯一的故障点。更好的方法是采取被动式，引入发布-订阅式通信模式。这样，发送方的通信将一次性地提供给订阅方微服务。实际上，当我们考虑例行场景时，任何模型的更新都会对其所有订阅者触发事件，这可能会进一步触发他们自己的模型的更改。为了避免这种情况，通常采用能够履行微服务间通信作用并充当消息代理的模式来引入事件总线。
 */

/**
 * 前端后端分离
 * 
 * 与其维护一个通用API，不如为每个用户体验或接口设计一个后端，更称之为前端后端（BFFs）​。
 * BFF与单一界面或特定的用户体验紧密相连，由其特定团队维护，以便轻松适应新的变化。
 * 在实施这种模式时，常见的问题之一是保持BFF的数量。更通用的解决办法是将关切事项分开，让各BFF自行负责。
 * 
 * 公平地考虑要维持的BFF数量。只有当可以为特定接口分离出一个普遍可用的服务之间的关切时，才创建一个新的BFF
 * BFF应该只包含客户端/接口特定的代码，以避免代码重复。‘
 */

/**
 * 网关聚合和卸载
 * 将专门的、通用的服务和功能丢弃或移到网关。
 * 此模式可通过将共享功能移动到单个部分来引入简单性。共享功能可以包括使用SSL证书、身份验证和授权等。网关还可用于将多个请求合并为单个请求。这种模式简化了客户机必须为某些操作多次调用不同的微服务的需求:
 * 
 * 此设计模式中的两个主要组件是网关和网关聚合器。网关聚合器应始终放置在网关后面。因此，实现了单一责任，每个组成部分都执行它们本应执行的业务。
 * 
 * 网关将一些常见操作（如证书管理、身份验证、SSL终止、缓存、协议转换等）卸载到一个位置。
 * 它简化了开发过程，并将所有这些逻辑抽象到一个地方，在一个庞大的组织中加快了开发速度，在这个组织中，并不是每个人都能够访问网关，只有专门的团队在工作。
 * 它在整个应用程序中保持一致性。该网关可以确保最小的日志记录量，从而帮助发现故障的微服务。这很像面向对象编程中的外表模式。
 * 
 * 网关聚合器:它接收客户端请求，然后决定向哪些不同的系统发送客户端请求，获取结果，然后聚合并将其发送回客户端。对于客户端来说，这只是一个请求。客户机和服务器之间的总往返次数减少。
 */


/**
 * 代理路由和节流
 * 
 * 当您有多个微服务要跨一个端点公开，且该单个端点根据需要路由服务时。
 * 当您需要处理迫在眉睫的瞬时故障，并对失败的操作进行重试循环时，此应用程序很有帮助，从而提高了应用程序的稳定性。当您想要处理微服务所使用的资源的消耗时，这种模式也非常有用。
 * 
 * 此模式用于满足协议的服务水平协议，并处理资源负载和资源分配消耗，即使需求的增加会对资源造成负载
 * 
 * 客户机必须消耗大量微服务时，很快就会遇到一些挑战，比如客户机管理每个端点和设置单独的端点。
 * 如果重构任何服务的代码的任何部分，那么客户端也必须更新，因为客户端直接与端点联系。
 * 此外，由于这些服务在云中，它们必须具有容错能力。故障包括暂时失去连接或服务不可用。
 * 这些错误应该是可以自我纠正的。例如，一个正在接受大量并发请求的数据库服务应该限制更多的请求，直到内存负载和资源利用率降低为止。
 * 在重试请求时，操作就完成了。任何应用程序的负载在时间段内都大不相同。例如，社交媒体聊天平台在办公高峰期的负载将非常低，购物门户网站在节日促销期间的负载会非常大。系统要想高效运行，就必须满足商定的LSA，一旦超出，则需要停止后续请求，直到负载消耗降低。
 * 
 * 解决方法:将网关层放置在微服务前面。此层包括节流组件，以及重试（一旦失败）组件。添加此层后，客户端只需与此网关进行交互，而无需与每个不同的微服务进行交互。
 * 它允许从客户端抽象后端调用，从而使客户端保持简单，因为客户端只需与网关交互。可以添加任意数量的服务，而无需在任何时间更改客户端。这个模式也可以用来有效地处理版本控制。
 * 微服务的新版本可以并行部署，网关也可以根据传递的输入参数路由。只需在网关级别更改配置，就可以轻松地维护新更改。
 * 这种模式可以作为自动缩放的替代策略。此层应该只允许网络请求达到一定限制，然后在资源被释放后限制请求并重试。这将有助于系统维护SLA。
 * 
 */

/**
 * 大使与边车模式
 * 
 * 当我们想要分离常见的连接特性（如监视、日志记录、路由、安全性、身份验证、授权等）时，会使用此模式。
 * 它设立了作为大使的辅助服务部门和副驾驶，以便代表某一服务部门发出请求。它只是位于进程之外的另一个代理。专业团队可以对此进行工作，让其他人不必担心，从而提供封装和隔离。还允许应用程序由多个框架和技术组成。
 * 
 * 找到一组在不同微服务中常见的操作，并将其置于各自的容器或进程中，从而为整个系统中的所有框架和平台服务提供这些常见操作的相同接口。添加大使层，在应用程序和微服务之间充当代理。
 * 此大使可以监视性能指标，如延迟量、资源使用率等。大使体内的任何东西都可以与申请无关地保存。大使可以作为容器、公共进程、守护程序或窗口服务部署。
 */

/**
 * 反腐败服务设计模式
 */

/**
 * 为了避免使用遗留代码或遗留系统，设计一个执行以下任务的层:作为与遗留代码通信的唯一层，这可以防止直接访问遗留代码，而不同的人可能会以不同的方式处理这些代码。核心概念是通过放置ACL来分离遗留应用程序或损坏的应用程序，目的是不改变遗留层，从而避免损害其方法或重大技术变革
 * 
 * 反腐层（ACL）应包含所有用于根据旧模型的新需求进行转换的逻辑。如果需要，可以在任何地方作为单独的服务或翻译器组件引入该层。组织ACL设计的一般方法是结合外观、适配器、翻译器和通信器与系统进行通信。ACL用于防止外部系统的意外行为在您的现有上下文中泄漏
 */

/**
 * Bulkhead设计模式
 * 
 * 将微服务应用程序中的不同服务分离到不同的池中，这样，如果其中一个服务失败，其他服务将继续运行而不论失败。为每个微服务创建不同的池，以尽量减少影响
 * 
 * 如果船体受损，那么只有受损部分会充满水，这将防止船只下沉。假设您连接到各种使用公共线程池的微服务。如果其中一个服务开始显示延迟，那么所有池成员都将疲惫不堪，无法等待响应。一个服务产生的大量请求会逐渐耗尽可用资源。这就是这个模式建议为每个服务建立一个专用的池的原因。
 * 
 * 根据负载和网络使用情况将服务实例分成不同的组。这使您可以隔离系统故障，并防止连接池中的资源耗尽。该系统的主要优点是防止故障的蔓延和配置资源池容量的能力。对于更高优先级的服务，您可以分配更高的池。
 * 
 * 
 */

/**
 * 断路器设计模式
 * 
 * 在微服务架构中，当存在服务间通信时，需要调用远程调用而不是内存调用。
 * 远程调用可能失败，或者达到超时限制并挂断而没有任何响应。现在在这样的情况下，当有许多调用者的时候，那么所有这些锁定的线程就会耗尽资源，整个系统就会变得无响应。
 * 
 * 解决这个问题的一个非常原始的想法是为受保护的函数调用引入一个包装器，它监视失败。现在，这个包装器可以通过任何方式触发，比如某个故障阈值、数据库连接失败等等。
 * 所有进一步的呼叫将返回错误并停止灾难性传播。这将使电路处于打开状态，当电路处于打开的状态时，将避免进行受保护的调用。实现就像在电路中一样，分以下三个阶段完成。它分三个阶段:关闭状态、打开状态和半打开状态
 */

/**
 * Strangler设计模式
 * 
 * 随着系统老化、新开发工具和托管选项的出现，维护当前系统的云和无服务器平台随着新特性和功能的加入而演变得非常痛苦。完全替换系统可能是一项巨大的任务，为此需要进行渐进式迁移，以便旧系统仍能处理尚未迁移的部分。这个模式解决了这个问题。
 * 
 * 
 */